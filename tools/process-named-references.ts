import * as fs from 'fs';
import * as path from 'path';

export const pairDivider = '~';
export const blockDivider = '~~';

type NamedReferences = Record<'xml' | 'html4' | 'html5', Record<string, {
    codepoints: number[];
    characters: string;
}>>

const getObjectEntries = Object.entries as <T>(obj: T) => [keyof T, T[keyof T]][];

type Level = keyof typeof namedReferences;

const result: {[key in Level]?: string} = {};

const regExpStart = '/';
const regExpEnd = '/g';
const regExpStartBody = '&(?:';
const regExpCommon = '#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)';
const regExpEndBody = ';?';

function entitityPairsToString(input: Map<string, string>) {
    return Array.from(input.entries()).map(([entity, characters]) => `${entity}${pairDivider}${characters}`).join(pairDivider);
}

const bodyRegExps: [string, string][] = [];
const namedReferences = JSON.parse(fs.readFileSync('tools/named-references.source.json', 'utf-8')) as NamedReferences;
const entitiesByLevel: Record<string, Record<string, string>> = {};
const processedEntities: Set<string> = new Set();
for (const [level, entityInfos] of getObjectEntries(namedReferences)) {
    const conflictingBodyRegExpNamedReferences: string[] = [];
    const bodyRegExpNamedReferences: string[] = [];
    const entities: string[] = Object.keys(entityInfos);
    const strictEntities = new Map(
        Object.entries(entityInfos)
            .filter(([entity]) => !processedEntities.has(entity))
            .map(([entity, {characters}]): readonly [string, string] => [entity.replace(/^&|;$/g, ''), characters])
    );
    entitiesByLevel[level] = {};
    const optionalEntities = new Map<string, string>();
    for (const [entity, {characters}] of getObjectEntries(entityInfos)) {
        if (level !== 'xml' && !processedEntities.has(entity)) {
            processedEntities.add(entity);
            if (!entity.endsWith(';')) {
                const entityName = entity.slice(1);
                optionalEntities.set(entityName, characters);
                strictEntities.delete(entityName);
            }
        }
        entitiesByLevel[level][entity] = characters;
        if (!entity.endsWith(';')) {
            bodyRegExpNamedReferences.push(entity.slice(1));
        } else {
            for (const otherEntity of entities) {
                if (otherEntity !== entity && otherEntity + ';' !== entity && entity.startsWith(otherEntity)) {
                    conflictingBodyRegExpNamedReferences.push(entity);
                }
            }
        }
    }

    result[level] = [
        entitityPairsToString(strictEntities),
        ...(optionalEntities.size > 0 ? [entitityPairsToString(optionalEntities)] : []),
    ].join(blockDivider);
    bodyRegExpNamedReferences.push(regExpCommon);
    bodyRegExps.push([
        level,
        regExpStart +
            conflictingBodyRegExpNamedReferences
                .concat(regExpStartBody + bodyRegExpNamedReferences.join('|') + regExpEndBody)
                .join('|') +
            regExpEnd
    ]);
}

const processedNamedReferences = `// This file is autogenerated by tools/process-named-references.ts
const pairDivider = ${JSON.stringify(pairDivider)};
const blockDivider = ${JSON.stringify(blockDivider)};

type GeneratedReferences = {
    entities: Record<string, string>;
    characters: Record<string, string>;
};

function generateNamedReferences(input: string, prev?: GeneratedReferences): GeneratedReferences {
    const entities: Record<string, string> = {};
    const characters: Record<string, string> = {};
    const blocks = input.split(blockDivider);
    let isOptionalBlock = false;
    for (let i = 0; blocks.length > i; i++) {
        const entries = blocks[i].split(pairDivider);
        for (let j = 0; j < entries.length; j+=2) {
            const entity = entries[j];
            const character = entries[j+1];
            const fullEntity = '&' + entity + ';';
            entities[fullEntity] = character;
            if (isOptionalBlock) {
                entities['&' + entity] = character;
            }
            characters[character] = fullEntity;
        }
        isOptionalBlock = true;
    }
    return prev ? 
        {entities: {...entities, ...prev.entities}, characters: {...characters, ...prev.characters}} :
        {entities, characters};
}

export type NamedReferences = {
    [K in ${Object.keys(result)
        .map((level) => `'${level}'`)
        .join(' | ')}]: {
        entities: Record<string, string>;
        characters: Record<string, string>;
    }
};
export const bodyRegExps = {
    ${bodyRegExps.map(([level, regExpStart]) => `${level}: ${regExpStart}`).join(',\n    ')}
};
export const namedReferences = {} as NamedReferences;
${
    Object.entries(result)
        .map(([level, data], index, all) => `namedReferences['${level}'] = generateNamedReferences(${JSON.stringify(data)}${
            index > 1 ? `, namedReferences['${all[index - 1][0]}']` : ''
        });`)
        .join('\n')
}
`;

fs.writeFileSync(path.join(__dirname, '..', 'src', 'named-references.ts'), processedNamedReferences);
